
Current long-term goals:

The way we handle bitpacked data in some of my experimental work isn't really viable. Currently, we generate data definitions and C struct definitions from XML files, but we have to work to keep those XML files in synch with the rest of the codebase (e.g. by duplicating preprocessor macro definitions into them). Plus, the tooling is compiled for Windows and therefore can't be incorporated into the build process.

It'd be better if we could somehow parse all of the C headers -- struct definitions, preprocessor macros, and the like -- and be able to generate data definitions based on some sort of annotation to the fields. Consider:

```c
#if _LU_C_PARSER
   //
   // Use C23-style attributes so we don't actually have to pay attention to code comments.
   // Comments can go any/*hello!*/where and would be nightmarish to try and handle rationally 
   // within an AST. Attributes, by contrast, are standard C (though too new for the compiler 
   // we build the game with) and have a fairly consistent position you can put them in.
   //
   #define BITPACK_THIS_STRUCT [[bitpack::struct]]
   #define BITPACKED_MEMBER_MINMAX(a, b) [[bitpack::minmax(a, b)]]
   #define BITPACKED_MEMBER_STRING [[bitpack::string]]
   #define BITPACKED_MEMBER_STRING_WITH_TERMINATOR [[bitpack::string_with_terminator]]
   #define BITPACKED_MEMBER_PREPACK(funcname) [[bitpack::pre_pack_function(#funcname)]]
   #define BITPACKED_MEMBER_POSTUNPACK(funcname) [[bitpack::post_unpack_function(#funcname)]]
   #define BITPACKED_MEMBER_OMIT_THIS_MEMBER [[bitpack::omit_this_member]]
   #define BITPACKED_MEMBER_USE_BITCOUNT(count) [[bitpack::bitcount(count)]]
#else
   #define BITPACK_THIS_STRUCT
   #define BITPACKED_MEMBER_MINMAX(a, b)
   #define BITPACKED_MEMBER_STRING
   #define BITPACKED_MEMBER_STRING_WITH_TERMINATOR
   #define BITPACKED_MEMBER_PREPACK(funcname)
   #define BITPACKED_MEMBER_POSTUNPACK(funcname)
   #define BITPACKED_MEMBER_OMIT_THIS_MEMBER
   #define BITPACKED_MEMBER_USE_BITCOUNT(count)
#endif

BITPACK_THIS_STRUCT
struct Foo {
   BITPACKED_MEMBER_MINMAX(0, 23)
   int bar;
   
   BITPACKED_MEMBER_STRING
   char trainerName[MAX_TRAINER_NAME_LEN];
   
   BITPACKED_MEMBER_PREPACK(GlobalItemIDToBerryPocketLocalItemID)
   BITPACKED_MEMBER_POSTUNPACK(BerryPocketLocalItemIDToGlobalItemID)
   BITPACKED_MEMBER_MINMAX(0, MAX_SERIALIZABLE_ITEM_ID_BY_POCKET_BERRIES)
   unsigned short berryID;
};
```

A custom-made C parser could potentially identify, operate on, or even expose to scripting (e.g. Lua):

* Macros which produce an integer constant
* Macros which produce a constant expression
* Constant data definitions (e.g. the list of structs defining properties of every inventory item)
  * For each data value, the ability to see the computed constant value (if any) and the expression that produced it (i.e. `7` or `TRAINER_NAME_LENGTH`)
  * For arrays, the ability to see whether a given entry's index is the result of a constant expression (e.g. the items array, which uses preprocessor-macro constants as indices)

A system like this could generate the appropriate data definitions we need in XML, or even just handle codegen directly. (We would want to generate *some* persistent representation of the format, so that we can detect format changes and automatically generate format "diffs" that could be used to upgrade savedata. These diffs could be incorporated into the game itself, allowing players to seamlessly load data; or they could be used as part of an external tool that users manually run on `.sav` files on their computer.) Interestingly, we could also use it, potentially, for doing codegen in a scripting language like Lua. For example, we could write a Lua script that reads the item definition array and generates mappings from "global" item IDs to "pocket-local" item IDs.[^1] Ideally we'd want to run the Lua-based codegen before any savedata/bitpacking codegen, so Lua can emit preprocessor macros (to define constants) that can be referenced in bitpacking (as shown above: for the imaginary `berryID` value, the pre-pack and post-unpack functions would be generated by Lua, as would the `MAX_SERIALIZABLE_ITEM_ID_BY_POCKET_...` constants).

[^1]: One of the optimizations I want to make to savedata is to codify item categorization by pocket into the serialized data format. In the vanilla engine, inventory items are divided into pockets in memory and in savedata, which means that the Poke Balls pocket is capable of storing HMs and berries if they end up in there from cheats or memory corruption. My thinking is, we should be aiming to remedy both of those cases anyway[^2], so why waste tons of bits on storing item types that can never go in a given pocket? If there are only a few dozen berry types, and about a dozen ball types, and so on, then use different bitcounts per pocket to store just the types that are valid there. We could define an overall Inventory struct for the in-memory bag, and write pre-pack and post-unpack functions that convert between Inventory and SerializedInventory, where the latter would specify the appropriate bitcounts per pocket.

[^2]: We should try to detect when people use GameShark or Action Replay cheats, show a warning screen, and direct them to a safe menu of in-game cheats for things like walking through walls or editing items. Ideally we'd eventually reproduce all the popular codes that are floating around.

There are benefits to a lot of this even beyond savedata bitpacking and updating. Potentially, we could set up codegen for things like menu GUI VRAM layouts that are tricky to manage in C alone.